# Effective Java, Third Edition
![EJ3e Book Cover](https://www.pearsonhighered.com/assets/bigcovers/0/1/3/4/0134685997.jpg)
## Hot News! Source code finally available on GitHub. Happy Hacking!

## 注意：项目基于 Java9 运行，虽然大部分是关于 Java8 及以下的，若环境为纯 Java8，则需要对不少代码做调整。

## 具体条目
### 创建和销毁对象
1. 用静态工厂方法代替构造器  
优点：  
 1）使用静态工厂方法相比构造器而言可以共享之前创造的对象，而不是每次都创建一个新对象。
2. 遇到多个构造器参数时要考虑使用构建器
3. 用私有构造器或者枚举类型强化 Singleton 属性
4. 通过抛出异常的私有构造器强化不可实例化的能力
5. 优先考虑依赖注入来引用资源，而不要使用 Singleton 和 静态工具类 来实现依赖一个或多个底层资源的类。  
 1）将这些资源传给工厂或构造器（或构建器），通过它们来创建类，这个过程就叫依赖注入
6. 避免创建不必要的对象  
 1）在对于像数据库连接这样的大对象（创建它比较耗费性能和资源），重用是有意义的；  
 2）但是对于一些轻量级的且场景要求我们创建的新对象，也不要吝惜创建  
7. 消除过期的对象引用  
内存泄漏的来源：  
 1）类是自己管理内存，容易造成内存泄漏；  
 2）缓存的积累容易造成内存泄漏；  
 3）监听器和其他回调，如果不及时取消注册，会积累慢慢造成内存泄漏
8. 避免使用终结方法和清除方法
9. try-with-resources 优先于 try-finally

### 对于所有对象都通用的方法
10. 覆盖 equals 时请遵守通用约定  
 面向对象语言的关于等价关系的一个基本问题：  
  1）我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留 equals 约定
11. 覆盖 equals 时总要覆盖 hashCode  
 1）如果两个对象调用 equals 相等，则对这两个对象调用 hashCode 所得的结果必须相等，反之不一定成立
12. 始终要覆盖 toString
13. 谨慎地覆盖 clone
14. 考虑实现 Comparable 接口  
 1）如果一个类已经实现了 Comparable 接口，请不要使用继承的方式扩展这个类，可以考虑使用聚合的方式，使这个类的对象作为另一个类的域，这样不影响新的类去实现 Comparable 接口

